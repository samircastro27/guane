import datetime
from enum import Enum
from typing import Optional, Any, Union

from pydantic import BaseModel, Field, validator


class SolverStatus(str, Enum):
    ok = "ok"  # Normal termination
    warning = "warning"  # Termination with unusual condition
    error = "error"  # Terminated internally with error
    aborted = "aborted"  # Terminated due to external conditions
    #   (e.g. interrupts)
    unknown = "unknown"  # An unitialized value


class SolverTerminationCondition(str, Enum):
    unknown = "unknown"  # An unitialized value
    # OK
    maxTimeLimit = (
        "maxTimeLimit"  # Exceeded maximum time limited allowed by user
    )
    #    but having return a feasible solution
    maxIterations = (
        "maxIterations"  # Exceeded maximum number of iterations allowed
    )
    #    by user (e.g., simplex iterations)
    minFunctionValue = (
        "minFunctionValue"  # Found solution smaller than specified function
    )
    #    value
    minStepLength = (
        "minStepLength"  # Step length is smaller than specified limit
    )
    globallyOptimal = "globallyOptimal"  # Found a globally optimal solution
    locallyOptimal = "locallyOptimal"  # Found a locally optimal solution
    feasible = "feasible"  # Found a solution that is feasible
    optimal = "optimal"  # Found an optimal solution
    maxEvaluations = (
        "maxEvaluations"  # Exceeded maximum number of problem evaluations
    )
    #    (e.g., branch and bound nodes)
    other = "other"  # Other, uncategorized normal termination
    # WARNING
    unbounded = "unbounded"  # Demonstrated that problem is unbounded
    infeasible = "infeasible"  # Demonstrated that the problem is infeasible
    infeasibleOrUnbounded = (
        "infeasibleOrUnbounded"  # Problem is either infeasible or unbounded
    )
    invalidProblem = (
        "invalidProblem"  # The problem setup or characteristics are not
    )
    #    valid for the solver
    intermediateNonInteger = (
        "intermediateNonInteger"  # A non-integer solution has been returned
    )
    noSolution = "noSolution"  # No feasible solution found but infeasibility
    #    not proven
    # ERROR
    solverFailure = "solverFailure"  # Solver failed to terminate correctly
    internalSolverError = "internalSolverError"  # Internal solver error
    error = "error"  # Other errors
    # ABORTED
    userInterrupt = "userInterrupt"  # Interrupt signal generated by user
    resourceInterrupt = (
        "resourceInterrupt"  # Interrupt signal in resources used by
    )
    #    optimizer
    licensingProblems = "licensingProblems"  # Problem accessing solver license


class IncomeVar(BaseModel):
    name: str
    value: float


class ExpenditureVar(BaseModel):
    name: str
    value: float


class LoanOutput(BaseModel):
    name: str
    stock: float
    installment: float
    extra_payments: float
    active: bool
    end_date: Optional[datetime.date]


class MortgageOutput(BaseModel):
    name: str
    stock: float
    installment: float
    extra_payments: float
    active: bool
    AFC_payment: float
    unemployment_payment: float
    end_date: Optional[datetime.date]


class TargetOutput(BaseModel):
    name: str
    planned: float
    stock: float
    contribution: float
    unemployment_contribution: Optional[float]
    values: Optional[list[float]]
    months_to_get: Optional[int]

    @validator("values", always=True)
    def list_value(cls, v, values):
        return [
            values["planned"],
            values["stock"],
            values["contribution"],
            values["unemployment_contribution"],
        ]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return [
            "Planeado",
            "Existente",
            "Contribución",
            "Contribución desde cesantías",
        ]


class RFOutput(BaseModel):
    name: str
    months: Optional[int]
    investment: float
    cashflow: float
    returns: Optional[float]
    date_returns: Optional[datetime.date]
    values: Optional[list[float]]

    @validator("values", always=True)
    def list_value(cls, v, values):
        return [values["investment"], values["cashflow"]]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return ["Inversión", "Flujo de caja"]


class PerOutput(BaseModel):
    name: str
    months: Optional[int]
    investment: float
    cashflow: float
    values: Optional[list[float]]
    returns: Optional[float]
    date_returns: Optional[datetime.date]

    @validator("values", always=True)
    def list_value(cls, v, values):
        return [values["investment"], values["cashflow"]]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return ["Inversión", "Flujo de caja"]


class DebtOutput(BaseModel):
    name: str
    months: int
    cashflow: Optional[float]
    stock: Optional[float]
    disbursement: Optional[float]

    fee_to_pay: Optional[float]

    @validator("fee_to_pay", always=True)
    def _fee_to_pay(cls, v, values: dict[str, Any]):
        cashflow = values.get("cashflow", 0)
        disbursement = values.get("disbursement", 0)
        if disbursement is not None and cashflow != disbursement:
            return disbursement - cashflow
        if cashflow < 0:
            return -cashflow


class ExpenditureOutput(BaseModel):
    fixed: float
    variable: list[ExpenditureVar]
    retirement: float
    healthcare: float
    prepaid_healthcare: float
    values: Optional[list[float]]

    @validator("values", always=True)
    def list_value(cls, v, values):
        return [
            values["fixed"],
            values["retirement"],
            values["healthcare"],
            values["prepaid_healthcare"],
        ] + [d.value for d in values["variable"]]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return [
            "Gastos fijos",
            "Pensión",
            "Salud",
            "Salud prepagada",
        ] + [d.name for d in values["variable"]]


class IncomeOutput(BaseModel):
    gross_salary: float
    net_salary: float
    variable_income: list[IncomeVar]
    bonuses: Optional[float]
    prima: Optional[float]
    last_balance: Optional[float]
    values: Optional[list[float]]

    @validator("values", always=True)
    def list_value(cls, v, values: dict[str, Any]):
        return [
            values.get("last_balance", 0),
            values.get("gross_salary", 0),
            values.get("prima", 0),
            values.get("bonuses", 0),
        ] + [d.value for d in values["variable_income"]]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return [
            "Balance mes anterior",
            "Salario neto",
            "Prima",
            "Bonus o primas",
        ] + [d.name for d in values["variable_income"]]


class UnemploymentInsuranceOutput(BaseModel):
    stock: float
    income: float
    interest_payment: float
    values: Optional[list[float]]

    @validator("values", always=True)
    def list_value(cls, v, values):
        return [values["income"], values["interest_payment"]]

    labels: Optional[list[str]]

    @validator("labels", always=True)
    def list_labels(cls, v, values):
        return ["Ingreso", "Pago de intereses"]


class Anticipated_taxes(BaseModel):
    wage: float
    riskfree_savings: float
    periodic_savings: float


class TaxesOutput(BaseModel):
    rents: float
    discounts: float
    representation_expenditures: float
    dependant_expenditures: float
    exemptions: float
    taxable_income: float
    tax_obligation: float
    positive_balance_with_dian: float
    anticipated_taxes: Anticipated_taxes
    payment: float


class SavingAccountOutput(BaseModel):
    stock: float


class AFCAccountOutput(BaseModel):
    stock: float
    contributions: float


class AccountOutput(BaseModel):
    saving: SavingAccountOutput
    AFC: AFCAccountOutput


class SolverOutput(BaseModel):
    status: SolverStatus
    condition: SolverTerminationCondition
    model_creation_time: float = Field(..., gt=0.0)
    solver_time: float = Field(..., gt=0.0)
    wallclock_time: float = Field(..., gt=0.0)
    resolved: bool
    n_iterations: int = Field(..., gt=1)


class BaseInterestSaving(BaseModel):
    name: str
    savings: float
    months: Optional[int]
    original_months: Optional[int]


class MortgageInterestSaving(BaseInterestSaving):
    ...


class LoanInterestSaving(BaseInterestSaving):
    ...


class KPIOutput(BaseModel):
    original_interest: float
    total_savings: float
    kyrk_interest: float
    kyrk_debts_interest: Optional[float]
    mortgage_savings: list[MortgageInterestSaving]
    loan_savings: list[LoanInterestSaving]
    money_invested_in_savings_options: float
    profits_by_saving_options: float
    saving_account_final_balance: float
    saving_account_final_balance_inflation: Optional[float]
    unemployment_insurance_final_balance: float
    feasible_var: Optional[dict[str, float]]
    total_debts: Optional[float]
    target_names: Optional[list[str]]
    months: Optional[int]
    equivalent_annual_rate: Optional[float]


class ComulativeRF(BaseModel):
    name: str
    total: float


class ComulativePer(BaseModel):
    name: str
    total: float


class FinancialMap(BaseModel):
    comulative_rfs: list[ComulativeRF] = Field(default_factory=list)
    comulative_pers: list[ComulativePer] = Field(default_factory=list)
    values: Optional[list[float]]
    labels: Optional[list[str]]

    @validator("values", always=True)
    def _values(cls, v: list[float], values: dict[str, Any]):
        v = [
            comulative_rf.total
            for comulative_rf in values.get("comulative_rfs", [])
            if comulative_rf.total > 0
        ]
        v += [
            comulative_per.total
            for comulative_per in values.get("comulative_pers", [])
            if comulative_per.total > 0
        ]
        return v

    @validator("labels", always=True)
    def _labels(cls, v: list[str], values: dict[str, Any]):
        v = [
            comulative_rf.name
            for comulative_rf in values.get("comulative_rfs", [])
            if comulative_rf.total > 0
        ]
        v += [
            comulative_per.name
            for comulative_per in values.get("comulative_pers", [])
            if comulative_per.total > 0
        ]
        return v


class ResultOutput(BaseModel):
    loans: list[LoanOutput]
    mortgages: list[MortgageOutput]
    targets: list[TargetOutput]
    RF_savings: list[RFOutput]
    Per_savings: list[PerOutput]
    debts: list[DebtOutput]
    unemployment_insurance: UnemploymentInsuranceOutput
    expenditures: ExpenditureOutput
    incomes: IncomeOutput
    taxes: TaxesOutput
    accounts: AccountOutput
    financial_map: FinancialMap
    kpis: Optional[KPIOutput]

    @validator("expenditures")
    def _investment_expenditures(
        cls, v: ExpenditureOutput, values: dict[str, Any]
    ):
        # Adding risk free product cashflow as expenditure
        rf_savings: list[RFOutput] = values.get("RF_savings", [])
        v.values += [rf_saving.investment for rf_saving in rf_savings]
        v.labels += [
            "Inversión en " + rf_saving.name for rf_saving in rf_savings
        ]

        # Adding periodic product cashflow as expenditure
        per_savings: list[RFOutput] = values.get("Per_savings", [])
        v.values += [
            abs(per_saving.cashflow)
            if per_saving.investment == 0 and per_saving.cashflow < 0
            else per_saving.investment
            for per_saving in per_savings
        ]
        v.labels += [
            f"{'Inversión' if per_saving.investment > 0 else 'Pago'} en "
            + per_saving.name
            for per_saving in per_savings
        ]

        # Adding targets contribution as expenditure
        targets: list[TargetOutput] = values.get("targets", [])
        v.values += [target.contribution for target in targets]
        v.labels += [
            "Movimiento a bolsillo de la meta " + target.name
            for target in targets
        ]

        # Adding loans payments as expenditures
        loans: list[LoanOutput] = values.get("loans", [])
        v.values += [loan.installment for loan in loans]
        v.values += [loan.extra_payments for loan in loans]
        v.labels += ["Pago de cuota, deuda " + loan.name for loan in loans]
        v.labels += ["Pago extra, deuda " + loan.name for loan in loans]

        # Adding mortgages payments as expenditures
        mortgages: list[MortgageOutput] = values.get("mortgages", [])
        v.values += [mortgage.installment for mortgage in mortgages]
        v.values += [mortgage.extra_payments for mortgage in mortgages]
        v.labels += [
            "Pago de cuota, hipoteca " + mortgage.name
            for mortgage in mortgages
        ]
        v.labels += [
            "Pago extra, hipoteca " + mortgage.name for mortgage in mortgages
        ]

        # Adding debts as expenditures
        debts: list[DebtOutput] = values.get("debts", [])
        v.values += [debt.fee_to_pay for debt in debts if debt.fee_to_pay]

        v.labels += [
            "Opción Kyrk (Pago): " + debt.name
            for debt in debts
            if debt.fee_to_pay
        ]

        return v

    @validator("incomes")
    def _investment_incomes(cls, v: IncomeOutput, values: dict[str, Any]):
        # Adding risk free product cashflow as income
        rf_savings: list[RFOutput] = values.get("RF_savings", [])
        v.values += [
            rf_saving.investment + rf_saving.cashflow
            for rf_saving in rf_savings
        ]
        v.labels += [
            "Retorno de " + rf_saving.name for rf_saving in rf_savings
        ]

        # Adding periodic product cashflow as income
        per_savings: list[RFOutput] = values.get("Per_savings", [])
        v.values += [
            abs(per_saving.cashflow) if per_saving.cashflow > 0 else 0
            for per_saving in per_savings
        ]
        v.labels += [
            f"Retorno de " + per_saving.name for per_saving in per_savings
        ]

        # Adding debts as incomes
        debts: list[DebtOutput] = values.get("debts", [])
        v.values += [debt.disbursement for debt in debts if debt.disbursement]

        v.labels += [
            "Opción Kyrk (Préstamo): " + debt.name
            for debt in debts
            if debt.disbursement
        ]

        unemployment_insurance: UnemploymentInsuranceOutput = values.get(
            "unemployment_insurance", None
        )
        v.values += (
            [unemployment_insurance.interest_payment]
            if unemployment_insurance.interest_payment > 0
            else []
        )
        v.labels += (
            ["Pago intereses cesantías"]
            if unemployment_insurance.interest_payment > 0
            else []
        )
        return v

    @validator("financial_map")
    def _financial_map(cls, v: FinancialMap, values: dict[str, Any]):
        targets: list[TargetOutput] = values.get("targets", [])
        v.values += [target.stock for target in targets]
        v.labels += [target.name for target in targets]

        accounts: AccountOutput = values.get("accounts")
        v.values += [accounts.saving.stock]
        v.labels += ["Cuenta de ahorros"]

        v.values += [accounts.AFC.stock] if accounts.AFC.stock > 0 else []
        v.labels += ["Cuenta AFC"] if accounts.AFC.stock > 0 else []

        unemployment_insurance: UnemploymentInsuranceOutput = values.get(
            "unemployment_insurance"
        )
        v.values += (
            [unemployment_insurance.stock]
            if unemployment_insurance.stock > 0
            else []
        )
        v.labels += ["Cesantías"] if unemployment_insurance.stock > 0 else []
        return v


class ResponseOutput(BaseModel):
    solver: Optional[SolverOutput]
    output: dict[int, dict[int, ResultOutput]]
    kpis: KPIOutput


class ResultsInDB(BaseModel):
    _id: str
    data: ResponseOutput


class ValuesLabels(BaseModel):
    values: list[float]
    labels: list[str]


class Stocks(BaseModel):
    name: str
    data: list[Union[Optional[ValuesLabels], float]] = []


class TargetStocks(Stocks):
    planned: Optional[float]


class StocksResponse(BaseModel):
    loans: list[Stocks]
    mortgages: list[Stocks]
    debts: list[Stocks]
    targets: list[TargetStocks]
    unemployment_insurance: list[Stocks]
